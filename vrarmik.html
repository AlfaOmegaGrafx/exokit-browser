<!doctype html>
<html>
  <head>
    <style>
body {
  margin: 0;
}
    </style>
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script type=module>
import Rig from './vrarmik/Rig.js';
import {Vector3, Quaternion} from './vrarmik/Unity.js';

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.y = 1.5;
camera.position.z = 2;
// camera.rotation.y = Math.PI;

const ambientLight = new THREE.AmbientLight(0x808080);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
directionalLight.position.set(0.5, 1, 0.5);
scene.add(directionalLight);

/* const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 1);
directionalLight2.position.set(0, -0.25, -0.25);
scene.add(directionalLight2); */

const gridHelper = new THREE.GridHelper(10, 10);
scene.add(gridHelper);

const cubeGeometry = new THREE.ConeBufferGeometry(0.05, 0.2, 3)
  .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
    new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)))
  );
const materials ={};
const _getCubeMaterial = color => {
  let material = materials[color];
  if (!material) {
    material = new THREE.MeshPhongMaterial({
      color,
      flatShading: true,
    });
    materials[color] = material;
  }
  return material;
}
const _makeCubeMesh = (color = 0x0000FF) => {
  const mesh = new THREE.Mesh(cubeGeometry, _getCubeMaterial(color));
  mesh.frustumCulled = false;
  return mesh;
};
const meshes = {
  hmd: _makeCubeMesh(0xFF0000),

  chest: _makeCubeMesh(0xFFFF00),
  shoulderLeft: _makeCubeMesh(0x00FF00),
  shoulderRight: _makeCubeMesh(0x008000),
  upperArmLeft: _makeCubeMesh(0x00FFFF),
  upperArmRight: _makeCubeMesh(0x008080),
  lowerArmLeft: _makeCubeMesh(0x0000FF),
  lowerArmRight: _makeCubeMesh(0x000080),
  handLeft: _makeCubeMesh(0xFFFFFF),
  handRight: _makeCubeMesh(0x808080),

  hips: _makeCubeMesh(0xFF0000),
  upperLegLeft: _makeCubeMesh(0xFFFF00),
  upperLegRight: _makeCubeMesh(0x808000),
  lowerLegLeft: _makeCubeMesh(0x00FF00),
  lowerLegRight: _makeCubeMesh(0x008000),
  footLeft: _makeCubeMesh(0xFFFFFF),
  footRight: _makeCubeMesh(0x808080),
};
for (const k in meshes) {
  scene.add(meshes[k]);
}
/* scene.remove(meshes.shoulderLeft);
scene.remove(meshes.upperArmLeft);
scene.remove(meshes.lowerArmLeft);
scene.remove(meshes.handLeft);
scene.remove(meshes.shoulderRight);
scene.remove(meshes.upperArmRight);
scene.remove(meshes.lowerArmRight);
scene.remove(meshes.handRight); */
/* scene.remove(meshes.shoulderRight);
scene.remove(meshes.upperLegRight);
scene.remove(meshes.lowerLegRight);
scene.remove(meshes.footRight); */

const renderer = new THREE.WebGLRenderer({
  // canvas: document.getElementById('canvas'),
  // alpha: true,
  antialias: true,
});
// console.log('set size', window.innerWidth, window.innerHeight);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
document.body.appendChild(renderer.domElement);

const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
orbitControls.screenSpacePanning = true;
orbitControls.enableMiddleZoom = false;
orbitControls.update();

const rig = new Rig();

function animate() {
  const standFactor = 0.2 + (Math.sin((Date.now()%2000)/2000*Math.PI*2) + 1) / 2;

  rig.inputs.hmd.position = new Vector3(0, 0.6 + standFactor, 0);
  rig.inputs.hmd.rotation = new Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.sin((Date.now()%2000)/2000*Math.PI*2)*Math.PI*0.2)
    .premultiply(new Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.sin((Date.now()%2000)/2000*Math.PI*2)*Math.PI*0.2));
  rig.inputs.leftGamepad.position = new Vector3(-0.5 + Math.sin((Date.now()%2000)/2000*Math.PI*2) * 0.3, 0.2 + standFactor, 0.3);
  rig.inputs.rightGamepad.position = new Vector3(0.5, standFactor + Math.sin((Date.now()%2000)/2000*Math.PI*2) * 0.3, 0.1 + Math.sin((Date.now()%2000)/2000*Math.PI*2) * 0.3);
  rig.inputs.hips.position = new Vector3(0, standFactor, 0);
  rig.inputs.leftFoot.position = new Vector3(-0.3, Math.max(standFactor - 1, 0), 0);
  rig.inputs.leftFoot.rotation = new Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.sin((Date.now()%2000)/2000*Math.PI*2)*Math.PI*0.2);
  rig.inputs.rightFoot.position = new Vector3(0.3, Math.max(standFactor - 1, 0), 0);

  rig.update();

  meshes.hmd.position.copy(rig.outputs.hmd.position);
  meshes.hmd.quaternion.copy(rig.outputs.hmd.rotation);

  meshes.chest.position.copy(rig.outputs.chest.position);
  meshes.chest.quaternion.copy(rig.outputs.chest.rotation);

  meshes.shoulderLeft.position.copy(rig.outputs.leftShoulder.position);
  meshes.shoulderLeft.quaternion.copy(rig.outputs.leftShoulder.rotation);
  meshes.upperArmLeft.position.copy(rig.outputs.leftUpperArm.position);
  meshes.upperArmLeft.quaternion.copy(rig.outputs.leftUpperArm.rotation);
  meshes.lowerArmLeft.position.copy(rig.outputs.leftLowerArm.position);
  meshes.lowerArmLeft.quaternion.copy(rig.outputs.leftLowerArm.rotation);
  meshes.handLeft.position.copy(rig.outputs.leftHand.position);
  meshes.handLeft.quaternion.copy(rig.outputs.leftHand.rotation);

  meshes.shoulderRight.position.copy(rig.outputs.rightShoulder.position);
  meshes.shoulderRight.quaternion.copy(rig.outputs.rightShoulder.rotation);
  meshes.upperArmRight.position.copy(rig.outputs.rightUpperArm.position);
  meshes.upperArmRight.quaternion.copy(rig.outputs.rightUpperArm.rotation);
  meshes.lowerArmRight.position.copy(rig.outputs.rightLowerArm.position);
  meshes.lowerArmRight.quaternion.copy(rig.outputs.rightLowerArm.rotation);
  meshes.handRight.position.copy(rig.outputs.rightHand.position);
  meshes.handRight.quaternion.copy(rig.outputs.rightHand.rotation);

  meshes.hips.position.copy(rig.outputs.hips.position);
  meshes.hips.quaternion.copy(rig.outputs.hips.rotation);

  meshes.upperLegLeft.position.copy(rig.outputs.leftUpperLeg.position);
  meshes.upperLegLeft.quaternion.copy(rig.outputs.leftUpperLeg.rotation);
  meshes.lowerLegLeft.position.copy(rig.outputs.leftLowerLeg.position);
  meshes.lowerLegLeft.quaternion.copy(rig.outputs.leftLowerLeg.rotation);
  meshes.footLeft.position.copy(rig.outputs.leftFoot.position);
  meshes.footLeft.quaternion.copy(rig.outputs.leftFoot.rotation);

  meshes.upperLegRight.position.copy(rig.outputs.rightUpperLeg.position);
  meshes.upperLegRight.quaternion.copy(rig.outputs.rightUpperLeg.rotation);
  meshes.lowerLegRight.position.copy(rig.outputs.rightLowerLeg.position);
  meshes.lowerLegRight.quaternion.copy(rig.outputs.rightLowerLeg.rotation);
  meshes.footRight.position.copy(rig.outputs.rightFoot.position);
  meshes.footRight.quaternion.copy(rig.outputs.rightFoot.rotation);

  renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);
    </script>
  </body>
</html>
