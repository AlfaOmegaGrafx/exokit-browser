<!doctype html>
<html>
  <head>
    <style>
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  background-color: #000;
  /* color: #F5F5F5; */
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;
  // font-weight: 300;
}
.body {
  display: flex;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}
header {
  position: absolute;
  display: flex;
  top: 0;
  left: 0;
  width: 100vw;
  height: 50px;
  background-color: #FFF;
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.08);
  align-items: center;
  user-select: none;
  z-index: 1;
}
header img {
  width: 50px;
  height: 50px;
  margin: 0 20px;
}
header nav {
  display: flex;
  height: 100%;
  padding: 0 10px;
  letter-spacing: 0.9px;
  align-items: center;
  text-transform: uppercase;
}
header nav span {
  display: flex;
  height: 30px;
  padding: 10px;
  border-radius: 4px;
  align-items: center;
}
header nav.selected span {
  background-color: #5c6bc0;
  color: #FFF;
  cursor: default;
}
header nav:not(.selected):hover {
  cursor: pointer;
}
header nav:not(.selected):hover span {
  background-color: #EEE;
}
.examples {
  width: 200px;
  padding-top: 50px;
  background-color: #FFF;
}
h1, h2, h3, h4, h5, h6, p {
  margin: 20px 0;
  padding: 0 20px;
  font-weight: inherit;
}
li {
  /* padding-left: 20px;
  padding-right: 20px; */
}
.iframe-wrapper {
  position: relative;
  display: flex;
  margin-top: 50px;
  flex: 1;
  background-color: #FFF;
}
.tabs {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}
.tabs .tab {
  display: inline-flex;
  margin: 5px 5px;
  padding: 5px 10px;
  background-color: #D8D8D8;
  border-radius: 4px;
  color: #000;
  align-items: center;
}
.tabs .tab .text {
  margin-right: 10px;
  align-items: center;
}
.tabs .tab .close-x {
  display: flex;
  width: 20px;
  height: 20px;
  background-color: #ef5350;
  color: #FFF;
  justify-content: center;
  align-items: center;
}
canvas {
  width: 100% !important;
  height: 100vh !important;
  background-color: #f8f8f8;
}
a {
  color: #AAA;
  text-decoration: none;
}
a:hover {
  color: #42a5f5;
}
a:active {
  color: #1976d2;
}
.buttons {
  position: absolute;
  right: 30px;
  bottom: 30px;
  display: flex;
  margin: 5px 20px;
}
.button {
  display: inline-flex;
  padding: 8px 20px;
  border: 2px solid;
  border-radius: 100px;
  color: #5c6bc0;
  cursor: pointer;
}
.button:not(:last-child) {
  margin-right: 20px;
}
.button:not([disabled]):hover {
  background-color: #5c6bc0;
  border-color: #5c6bc0;
  color: #FFF;
}
.button[disabled] {
  color: #b71c1c;
  cursor: auto;
}
#code-header:not(.open),
#code-button:not(.open) .opened-text,
#code-button.open .closed-text
{
  display: none;
}
.coming-soon {
  color: #ccc;
}
.coming-soon-sub {
  font-size: 10px;
  display: block;
}
.header-link {
  color: #666;
}
.code-header {
  position: absolute;
  top: 50px;
  right: 0;
  display: flex;
  align-items: center;
  width: 600px;
  height: 32px;
  padding: 5px;
  font-size: 13px;
  color: #4caf50;
  background-color: #f2f3f5;
}
.code {
  position: absolute;
  top: 82px;
  bottom: 0;
  right: 0;
  width: 600px;
  border: 0;
  border-left: 5px solid #f2f3f5;
  outline: none;
}
.code:not(.open) {
  display: none;
}
    </style>
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="FBXLoader.js"></script>
    <script src="inflate.min.js"></script>
    <script src="gunzip.min.js"></script>
    <script src="ProgressivePromise.js"></script>
    <script src="untar.js"></script>
  </head>
  <body>
    <div class=body>
      <header>
        <img src="logo.svg">
        <nav class=selected><span>Viewer</span></nav>
        <a href="https://docs.exokit.org/"><nav><span class="header-link">Documentation</span></nav></a>
        <a href="https://browser.exokit.org"><nav><span class="header-link">Browser
        </span></nav></a>
        <a href="https://discord.gg/UgZDFZW"><nav><span class="coming-soon">Exoland
          <p class="coming-soon-sub">Coming soon!</p>
        </span></nav></a>
      </header>

      <div class=examples>
        <h3>Examples</h3>
        <p>
          <a href="https://exokitxr.github.io/avatar-models/model.glb" class="a-avatar">model.glb</a><br>
          <a href="https://exokitxr.github.io/avatar-models/model2.vrm" class="a-avatar">model2.vrm</a><br>
          <a href="https://exokitxr.github.io/avatar-models/model3.unitypackage" class="a-avatar">model3.unitypackage</a><br>
        </p>
      </div>

      <div class=iframe-wrapper id=iframe-wrapper></div>

      <div class=buttons>
        <a class=button id="enter-xr-button" style="display: none;">Enter XR</a>
        <a class=button id="no-xr-button" disabled style="display: none;">No XR</a>
      </div>
    </div>
    <script type=module>
import Rig from './vrarmik/Rig.js';
import {Vector3, Quaternion} from './vrarmik/Unity.js';

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.y = 1.5;
camera.position.z = 2;
// camera.rotation.y = Math.PI;

const ambientLight = new THREE.AmbientLight(0x808080);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
directionalLight.position.set(0.5, 1, 0.5);
scene.add(directionalLight);

/* const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 1);
directionalLight2.position.set(0, -0.25, -0.25);
scene.add(directionalLight2); */

const gridHelper = new THREE.GridHelper(10, 10);
scene.add(gridHelper);

const cubeGeometry = new THREE.ConeBufferGeometry(0.05, 0.2, 3)
  .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
    new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)))
  );
const materials ={};
const _getCubeMaterial = color => {
  let material = materials[color];
  if (!material) {
    material = new THREE.MeshPhongMaterial({
      color,
      flatShading: true,
    });
    materials[color] = material;
  }
  return material;
}
const _makeCubeMesh = (color = 0x0000FF) => {
  const mesh = new THREE.Mesh(cubeGeometry, _getCubeMaterial(color));
  mesh.frustumCulled = false;
  if (color === 0x008000 || color === 0x808000) {
    // mesh.add(new THREE.AxesHelper());
  }
  return mesh;
};
const meshes = {
  eyes: _makeCubeMesh(0xFF0000),
  head: _makeCubeMesh(0xFF8080),

  chest: _makeCubeMesh(0xFFFF00),
  shoulderLeft: _makeCubeMesh(0x00FF00),
  shoulderRight: _makeCubeMesh(0x008000),
  upperArmLeft: _makeCubeMesh(0x00FFFF),
  upperArmRight: _makeCubeMesh(0x008080),
  lowerArmLeft: _makeCubeMesh(0x0000FF),
  lowerArmRight: _makeCubeMesh(0x000080),
  handLeft: _makeCubeMesh(0xFFFFFF),
  handRight: _makeCubeMesh(0x808080),

  hips: _makeCubeMesh(0xFF0000),
  upperLegLeft: _makeCubeMesh(0xFFFF00),
  upperLegRight: _makeCubeMesh(0x808000),
  lowerLegLeft: _makeCubeMesh(0x00FF00),
  lowerLegRight: _makeCubeMesh(0x008000),
  footLeft: _makeCubeMesh(0xFFFFFF),
  footRight: _makeCubeMesh(0x808080),
};
for (const k in meshes) {
  scene.add(meshes[k]);
}
/* scene.remove(meshes.shoulderLeft);
scene.remove(meshes.upperArmLeft);
scene.remove(meshes.lowerArmLeft);
scene.remove(meshes.handLeft);
scene.remove(meshes.shoulderRight);
scene.remove(meshes.upperArmRight);
scene.remove(meshes.lowerArmRight);
scene.remove(meshes.handRight);
scene.remove(meshes.shoulderRight);
scene.remove(meshes.upperLegRight);
scene.remove(meshes.lowerLegRight);
scene.remove(meshes.footRight); */

const z180Quaternion = new Quaternion().setFromAxisAngle(new Vector3(0, 1, 0), Math.PI);

let rig = null;
let model = null;
const _rigModel = object => {
  if (rig) {
    scene.remove(model);
    rig = null;
    model = null;
  }

  model = object;
  rig = new Rig(model);
  scene.add(model);
  window.model = model;
};
const _loadModel = async (href, filename = href) => {
  if (/\.(?:glb|vrm)$/.test(filename)) {
    new THREE.GLTFLoader().load(href, object => {
      _rigModel(object.scene);
    }, xhr => {}, err => {
      console.warn(err);
    });
  } else if (/\.unitypackage$/.test(filename)) {
    const unitypackageRes = await fetch(href);
    const arraybuffer = await unitypackageRes.arrayBuffer();
    const inflatedArrayBuffer = new Zlib.Gunzip(new Uint8Array(arraybuffer)).decompress().buffer;
    const files = await untar(inflatedArrayBuffer);
    // console.log('got files', files);
    // window.files = files;

    const filesystem = [];
    for (let j = 0; j < files.length; j++) {
      const file = files[j];
      const {name} = file;
      const match = name.match(/^([a-zA-Z0-9]+)\/pathname$/);
      if (match) {
        const pathname = new TextDecoder().decode(await file.blob.arrayBuffer());
        const id = match[1];
        const assetFileName = `${id}/asset`;
        const assetFile = files.find(file => file.name === assetFileName);
        if (assetFile) {
          const match = pathname.match(/([^\/]+)$/);
          const filename = match[1];
          const url = assetFile.getBlobUrl();
          filesystem.push({
            id,
            pathname,
            filename,
            url,
          });
        }
      }
    }
    // window.filesystem = filesystem;

    const manager = new THREE.LoadingManager();
    manager.setURLModifier(url => {
      // console.log('load url', url);
      const match = url.match(/([^\/]+)$/);
      if (match) {
        const filename = match[1];
        const file = filesystem.find(file => file.filename === filename);
        if (file) {
          // console.log('replace url', url, file.url);
          url = file.url;
        }
      }
      return url;
    });

    const modelFileUrl = filesystem.find(file => file.pathname === 'Assets/1Avatars/rachel gardner 1/rachel gardner NEW.fbx').url;
    const loader = new THREE.FBXLoader(manager);
    loader.load(modelFileUrl, object => {
      _rigModel(object);
    }, function onprogress() {

    }, function onerror(err) {
      console.warn(err);
    });
    // window.loader = loader;
    console.log('got filesystem', modelFileUrl, loader);
  } else {
    throw new Error('unknown file type');
  }
};

window.document.addEventListener('dragover', e => {
  e.preventDefault();
});
window.document.addEventListener('drop', async e => {
  e.preventDefault();

  if (e.dataTransfer.items.length !== 1) {
    return;
  }

  for (var i = 0; i < e.dataTransfer.items.length; i++) {
    if (e.dataTransfer.items[i].kind === 'file') {
      const file = e.dataTransfer.items[i].getAsFile();
      // console.log('got file', e.dataTransfer.items[i], file);
      const dataUrl = URL.createObjectURL(file);
      _loadModel(dataUrl, file.name);
    }
  }
});

const renderer = new THREE.WebGLRenderer({
  // canvas: document.getElementById('canvas'),
  // alpha: true,
  antialias: true,
});
// console.log('set size', window.innerWidth, window.innerHeight);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
document.getElementById('iframe-wrapper').appendChild(renderer.domElement);

const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
orbitControls.screenSpacePanning = true;
orbitControls.enableMiddleZoom = false;
orbitControls.update();

const aAvatars = document.querySelectorAll('.a-avatar');
for (let i = 0; i < aAvatars.length; i++) {
  const aAvatar = aAvatars[i];
  aAvatar.addEventListener('click', e => {
    e.preventDefault();

    const {href} = aAvatar;
    _loadModel(href);
  });
}
_loadModel(aAvatars[0].href);

const realDateNow = (now => () => now())(Date.now);//() => 2000;
function animate() {
  if (rig) {
    const positionOffset = Math.sin((realDateNow()%10000)/10000*Math.PI*2)*2;
    const standFactor = 1.3412381613714757 - 0.3 + Math.sin((realDateNow()%2000)/2000*Math.PI*2)*0.3;
    const rotationAngle = (realDateNow()%10000)/10000*Math.PI*2;

    // rig.inputs.hmd.position = new Vector3(positionOffset, 0.6 + standFactor, 0);
    rig.inputs.hmd.position = new Vector3(positionOffset, standFactor, 0);
    rig.inputs.hmd.rotation = new Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationAngle)
      .multiply(new Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.sin((realDateNow()%2000)/2000*Math.PI*2)*-Math.PI*0.4));
      // .premultiply(new Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.sin((Date.now()%2000)/2000*Math.PI*2)*Math.PI*0.2));

    rig.inputs.rightGamepad.rotation = new Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationAngle);
    rig.inputs.rightGamepad.position = new Vector3(positionOffset, 0, 0).add(
      new Vector3(-0.2, 0.9, -0.2/**Math.sin((realDateNow()%2000)/2000*Math.PI*2)*/)
        .applyQuaternion(rig.inputs.rightGamepad.rotation)
        //.applyQuaternion(z180Quaternion)
      );
    rig.inputs.leftGamepad.rotation = new Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationAngle);
    rig.inputs.leftGamepad.position = new Vector3(positionOffset, 0, 0).add(
      new Vector3(0.2, 0.9, -0.2)
        .applyQuaternion(rig.inputs.leftGamepad.rotation)
        // .applyQuaternion(z180Quaternion)
      );

    rig.update();

    meshes.eyes.position.copy(rig.outputs.eyes.position);
    meshes.eyes.quaternion.copy(rig.outputs.eyes.rotation);

    meshes.head.position.copy(rig.outputs.head.position);
    meshes.head.quaternion.copy(rig.outputs.head.rotation);

    meshes.chest.position.copy(rig.outputs.chest.position);
    meshes.chest.quaternion.copy(rig.outputs.chest.rotation);

    meshes.shoulderLeft.position.copy(rig.outputs.leftShoulder.position);
    meshes.shoulderLeft.quaternion.copy(rig.outputs.leftShoulder.rotation);
    meshes.upperArmLeft.position.copy(rig.outputs.leftUpperArm.position);
    meshes.upperArmLeft.quaternion.copy(rig.outputs.leftUpperArm.rotation);
    meshes.lowerArmLeft.position.copy(rig.outputs.leftLowerArm.position);
    meshes.lowerArmLeft.quaternion.copy(rig.outputs.leftLowerArm.rotation);
    meshes.handLeft.position.copy(rig.outputs.leftHand.position);
    meshes.handLeft.quaternion.copy(rig.outputs.leftHand.rotation);

    meshes.shoulderRight.position.copy(rig.outputs.rightShoulder.position);
    meshes.shoulderRight.quaternion.copy(rig.outputs.rightShoulder.rotation);
    meshes.upperArmRight.position.copy(rig.outputs.rightUpperArm.position);
    meshes.upperArmRight.quaternion.copy(rig.outputs.rightUpperArm.rotation);
    meshes.lowerArmRight.position.copy(rig.outputs.rightLowerArm.position);
    meshes.lowerArmRight.quaternion.copy(rig.outputs.rightLowerArm.rotation);
    meshes.handRight.position.copy(rig.outputs.rightHand.position);
    meshes.handRight.quaternion.copy(rig.outputs.rightHand.rotation);

    meshes.hips.position.copy(rig.outputs.hips.position);
    meshes.hips.quaternion.copy(rig.outputs.hips.rotation);

    meshes.upperLegLeft.position.copy(rig.outputs.leftUpperLeg.position);
    meshes.upperLegLeft.quaternion.copy(rig.outputs.leftUpperLeg.rotation);
    meshes.lowerLegLeft.position.copy(rig.outputs.leftLowerLeg.position);
    meshes.lowerLegLeft.quaternion.copy(rig.outputs.leftLowerLeg.rotation);
    meshes.footLeft.position.copy(rig.outputs.leftFoot.position);
    meshes.footLeft.quaternion.copy(rig.outputs.leftFoot.rotation);

    meshes.upperLegRight.position.copy(rig.outputs.rightUpperLeg.position);
    meshes.upperLegRight.quaternion.copy(rig.outputs.rightUpperLeg.rotation);
    meshes.lowerLegRight.position.copy(rig.outputs.rightLowerLeg.position);
    meshes.lowerLegRight.quaternion.copy(rig.outputs.rightLowerLeg.rotation);
    meshes.footRight.position.copy(rig.outputs.rightFoot.position);
    meshes.footRight.quaternion.copy(rig.outputs.rightFoot.rotation);
  }

  renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);

let session = null;
const enterXrButton = document.getElementById('enter-xr-button');
const noXrButton = document.getElementById('no-xr-button');
(async () => {
  let result;
  if (navigator.xr) {
    try {
      await navigator.xr.supportsSession('immersive-vr');
      result = true;
    } catch (err) {
      result = false;
    }
  } else {
    result = false;
  }
  if (result) {
    console.log('xr available');
    enterXrButton.style.display = null;
  } else {
    console.log('no xr');
    noXrButton.style.display = null;
  }
})();
enterXrButton.addEventListener('click', async () => {
  session = await navigator.xr.requestSession({
    exclusive: true,
  });
  session.layers = layers;

  // console.log('request first frame');
  session.requestAnimationFrame((timestamp, frame) => {
    renderer.vr.setSession(session, {
      frameOfReferenceType: 'stage',
    });

    const pose = frame.getViewerPose();
    const viewport = session.baseLayer.getViewport(pose.views[0]);
    // const width = viewport.width;
    const height = viewport.height;
    const fullWidth = (() => {
      let result = 0;
      for (let i = 0; i < pose.views.length; i++) {
        result += session.baseLayer.getViewport(pose.views[i]).width;
      }
      return result;
    })();
    renderer.setSize(fullWidth, height);
    renderer.setPixelRatio(1);

    renderer.setAnimationLoop(null);

    renderer.vr.enabled = true;
    renderer.vr.setSession(session);
    renderer.vr.setAnimationLoop(animate);

    console.log('loaded root in XR');
  });
});
    </script>
  </body>
</html>
